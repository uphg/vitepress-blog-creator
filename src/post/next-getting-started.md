---
title: Next.js 入门
date: 2022-03-26T16:32:22+08:00
---

## Next.js 的背景

- 开发团队是 zeit，后改名为 Vercel
- zeit 团队的水平：[ZEIT.co 是什么样一个组织?](https://www.zhihu.com/question/59278159/answer/813629215)
- Next.js 核心团队平均年龄在 20 岁，几乎每个同事都有非常强大的背景。

## Next.js 的定位

**优点（全栈框架）**

- CSS-in-JS
- 页面预渲染 + SSR（服务端渲染）
- 前后端同构（代码同时运行在两端）
- Node.js 10.13 以上
- React
- TypeScript

**弱项**

- 完全没有提供数据库相关功能， 可自行搭配 Sequelize 或 TypeORM
- 完全没有提供测试相关功能，可自行搭配 Jest 或 Cypress
- 有一个叫做 [Blitz.js](https://github.com/blitz-js/blitz) 框架在补全这方面功能

## 谁在用 Next.js

**国内**

- 腾讯网手机版 https://xw.qq.com/
- [Teambition](https://www.teambition.com/)

**国外**

- Netflix Jobs、Twitch 手机版、Hulu、TikTok 抖音海外版、漫威官网、Material UI 官网

## 使用 Next.js 创建博客项目

- `npm init next-app nextjs-blog-1`
- 选择 Default starter app
- 打开 nextjs-blog-1
- 运行 `yarn dev`

## Next.js 项目特点

- 约定大于配置
- 不需要配置，只需要约定，开发者自然会领会
- Rails 的理念

## Link 导航

**用法**

- [官方教程](https://nextjs.org/learn/basics/navigate-between-pages/link-component)
- 将 `<a href=xxx>点击链接</a>` 替换为 `<Link href=xxx><a>点击链接</a></Link>`

**优点**

- 页面不会刷新，只会用 AJAX 请求新页面的 JS
- 不会请求重复的 HTML、CSS、JS
- 自动在页面插入新内容、删除旧内容
- 因此省去了很多请求和解析过程，所以速度极快
- 借鉴了 Rails Turbolinks、pjax 等技术

## 同构代码

- 代码同时在 Node.js 和浏览器端运行
- 在组件内添加一个 `console.log('hi')`
- 你会发现 Node 控制台也会输出这句话
- 你会发现 Chrome 控制台也会输出这句话

注意

- 不是所有代码都会同时运行，有些需要用户触发的就不会（例如 button 的 onClick 事件）
- 必须使用两种环境都兼容的 API，比如 window 在 Node 里会报错，就会导致两个端都报错

## 自定义 Head

自定义当前页面的 Head

```js
// pages/posts/first-blog.js
import Link from "next/link";
import Head from "next/head";

export default function FirstBlog() {
  return (
    <>
      <Head>
        <title>第一篇博客</title>
      </Head>
      <div>
        <h2>First Blog</h2>
        <Link href="/"><a>回到首页</a></Link>
      </div>
    </>
  )
}
```

## 修改全局 Head

创建 `./pages/_app.js` 文件，添加以下内容，其中 Component 表示渲染页面内容的位置

```js
import '../styles/globals.css'
import Head from "next/head";

function MyApp({ Component, pageProps }) {
  return (
    <>
      <Head>
        <title>Jack 的个人博客</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Component {...pageProps} />
    </>
  )
}

export default MyApp
```

## 全局 CSS

- 放在 `_app.js` 中
- 使用 `import '../styles/global.css'` 引入
- 其他地方不能使用 `import 'xxx'` 引入 CSS，只能添加局部 CSS
- 可以配置 [Absolute Imports](https://nextjs.org/docs/advanced-features/module-path-aliases) 改成绝对路径引入（`import 'styles/global.css'`）

## 局部 CSS

官方支持

- 默认支持 [styled-jsx](https://nextjs.org/learn/basics/assets-metadata-css/css-styling) 和 [CSS Modules](https://nextjs.org/learn/basics/assets-metadata-css/layout-component)
- 简单的需求使用前者，复杂的需求使用后者

个人推荐

- styled-jsx 不方便分离 CSS 和 JS
- CSS Modules 引用太长
- 更推荐使用 [styled-components](https://styled-components.com/)

使用 Sass

- 安装依赖 `yarn add sass`
- 修改后缀名后直接引用

## 图片引入

官方内置了 Image 组件用于添加图片，假如想要引用 `assets/images/demo.jpg` 下的图片

```js
import imgDemo from 'assets/images/demo.jpg'
import Image from 'next/image'

export default function FirstBlog() {
  return (
    <Image src={imgDemo} alt="" />
  )
}
```

## 添加 TypeScript

安装相关依赖

```sh
yarn add -D typescript @types/react @types/node @types/react-dom
```

重命名文件名后缀为 `*.tsx`

## 创建 Next.js API

- 使用 `pages/api/v1/xxx` 作为 API 的默认路径，方便与页面路径区分
- 默认导出的函数类型为 NextApiHandler
- 该代码只在 Node.js 中运行，不在浏览器中运行

### 获取用户信息

```tsx
// ./pages/api/v1/userinfo.tsx
import { NextApiHandler } from "next"

const Userinfo: NextApiHandler = (request, response) => {
  response.statusCode = 200
  response.setHeader('Content-Type', 'application/json')
  response.write(JSON.stringify({ name: 'Jack' }))
  response.end()
}

export default Userinfo
```

请求 `/api/v1/userinfo` 获取该数据

### 获取本地 Markdown 内容

封装 getPosts 方法，该方法使用 gray-matter 获取本地 Markdown 内容

```js
// 封装 getPosts
import path from 'path'
import fs, { promises as fsPromise } from 'fs'
import matter from 'gray-matter'

export const getPosts = async () => {
  const dir = path.join(process.cwd(), 'posts')
  const fileNames = await fsPromise.readdir(dir)
  const result: { date: string, title: string, id: string }[] = []
  fileNames.map((fileName, index) => {
    const fullPath = path.join(dir, fileName)
    const id = fileName.replace(/\.md$/g, '')
    const text = fs.readFileSync(fullPath, 'utf-8')
    const { data: { title, date }, content } = matter(text)
    result[index] = {
      date,
      title,
      id
    }
  })
  return result
}
```

使用

```js
import { getPosts } from "lib/posts"
import { NextApiHandler } from "next"

const Posts: NextApiHandler = async (request, response) => {
  response.statusCode = 200
  response.setHeader('Content-Type', 'application/json')
  const posts = await getPosts()
  response.write(JSON.stringify(posts))
  response.end()
}

export default Posts
```

## Next.js 三种渲染方式

客户端渲染（SPA）

- 只在浏览器上执行重新渲染

静态页面生成（SSG）

- Static Site Generation，解决白屏问题、SEO 问题
- 无法生成用户相关内容（所有用户请求页面的结果都一样）

服务端渲染（SSR）

- 解决白屏问题、SEO 问题
- 可以生成用户相关内容（不同用户生成不同的内容）

> 注意：SSR 和 SSG 都属于预渲染 Pre-rendering

三种渲染方式分别对应

- 客户端渲染：用 JavaScript（Vue、React） 创建 HTML
- SSG：页面静态化，类似于把 PHP 提前渲染成 HTML
- SSR：PHP、Python、Ruby、Java 后台基本功能

不同点

- Next.js 的预渲染可以与前端 React 无缝对接，详见下文

## 客户端渲染

- 内容完全由前端渲染，称之为客户端渲染
- 通常会渲染两次 DOM ，第一次是后端渲染（加载页面），第二次是前端对比后端渲染（查看是否一致）

## 静态页渲染（SSG）

使用 SSG 静态渲染，需要调用 getStaticProps 方法

```js
import { GetStaticProps, NextPage } from 'next';
import { getPosts } from 'lib/posts';

// SSG静态页渲染
type Post = {
  id: string;
  title: string;
  date: string;
}

type Props = {
  posts: Post[]
}

const PostsIndex: NextPage<Props> = (props) => {
  console.log('props.posts')
  console.log(props.posts)
  return (
    <div>
      <h2>文章列表</h2>
      {props.posts.map((item) => <div key={item.id}>{item.title}</div>)}
    </div>
  )
}

export const getStaticProps = async () => {
  const posts = await getPosts()
  return {
    props: {
      posts: JSON.parse(JSON.stringify(posts))
    }
  }
}

export default PostsIndex
```

该方式渲染后页面内容是直接渲染为 HTML 标签，前端只负责绑定 JavaScript 事件部分。

### 同构

前端通过存储在 `<script type="application/json">` 标签的 JSON 数据获取与后端同步的数据 posts。 

![SSG 静态页渲染](/images/nextjs-ssg-demo.jpg)

### 静态化的时机

环境

- 在开发环境，每次请求都会运行一次 getStaticProps
- 这是为了方便你修改代码重新运行
- 在生产环境，getStaticProps 只在 build 时运行一次
- 这样可以提供一份 HTML 给所有用户下载

如何体验生产环境

1. 终止 `yarn dev`
2. `yarn build`
3. `yarn start`

## 生产环境

**三种状态解读**

- (Server) 不能自动创建 HTML
- (Static) 自动创建 HTML（发现你没用到 props）
- (SSG) 自动创建 HTML JavaScript JSON（发现你用到了 props）

**三种文件的类型**

- posts.html 含有静态内容，用于用户直接访问
- posts.js 也含有静态内容，用于快速导航（与 HTML 对应）
- posts.json 含有数据，和 posts.js 结合得到页面

**为什么不直接把数据放在 posts.js 中呢？**

- 显然是为了让 posts.js 接受不同数据
- 当然，目前只接受来自 getStaticProps 的数据

**静态页跳转机制**

如果直接访问 posts 页，会直接渲染该页面的 HTML 和 JavaScript（posts.html） 。如果通过 Next 提供的 Link 组件跳转，会预先请求 posts.js 和 posts.json，直接将当前页数据替换为该页面数据，并修改 url 导航。

## 服务端渲染

使用 [getServerSideProps](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props) 方法实现服务端渲染，通过 [ua-parser-js](https://github.com/faisalman/ua-parser-js) 插件获取当前浏览器类型

```tsx
import { GetStaticProps, NextPage } from 'next';
import { getPosts } from 'lib/posts';
import Link from 'next/link';
import Post from 'interface/post';

// SSG静态页渲染
type Props = {
  posts: Post[]
}

const PostsIndex: NextPage<Props> = (props) => {
  return (
    <div>
      <h2>文章列表</h2>
      {props.posts.map((item) => <div key={item.id}>
        <Link href={`/posts/${item.id}`}><a>{item.title}</a></Link>
      </div>)}
    </div>
  )
}

export const getStaticProps: GetStaticProps = async () => {
  const posts = await getPosts()
  return {
    props: {
      posts: JSON.parse(JSON.stringify(posts))
    }
  }
}

export default PostsIndex
```

## 使用 `[id].tsx` 实现

- 创建 `pages/posts/[id].tsx`
- `pages/posts/[id].tsx` 的作用：既声明路由，又是 `posts/:id` 的页面实现

**步骤**

- 实现 PostsShow，从 props 接收 post 数据
- 实现 getStaticProps，从第一个参数接受 `params.id`
- 实现 getStaticPaths，返回 id 列表 

示例

```tsx
import { NextPage, GetStaticPaths, GetStaticPropsContext } from "next"
import { getPost, getPostIds } from "lib/posts"
import Post from 'interface/post';

type Props = {
  post: Post
}

const postsShow: NextPage<Props> = (props) => {
  const { post } = props

  return (
    post ? (
      <div>
        <h1>{post?.title}</h1>
        <article dangerouslySetInnerHTML={{ __html: post?.htmlContent }}></article>
      </div>
    ) : null
  )
}

export default postsShow

export const getStaticPaths: GetStaticPaths = async () => {
  const ids: string[] = await getPostIds()

  return {
    paths: ids.map((id) => ({ params: { id } })),
    fallback: true // 处理 404 页面
  }
}

export const getStaticProps = async (context: GetStaticPropsContext<{ id: string }>) => {
  const id = context.params?.id || ''
  const post = await getPost(id)

  return {
    props: {
      post: post
    }
  }
}
```

### fallback 属性

- 是否自动兜底
- `false` 表示如果请求的 id 不存在 getStaticPaths 的结果里，则直接返回 404 页面
- `true` 表示自动兜底， id 找不到[依然渲染页面](https://nextjs.org/docs/basic-features/data-fetching/overview#fallback-pages)
- 注意 id 不再结果里不代表 id 不存在，比如大型项目无法将所有产品页面都静态化，只会静态化部分 id 对应页面（热门页面）

## 封装 Session

安装 [iron-session](https://github.com/vvo/iron-session)

```sh
yarn add iron-session
```

封装 session，在 `lib/withSession.ts` 添加如下内容

```ts
import { IronSessionOptions } from 'iron-session'
import { withIronSessionApiRoute, withIronSessionSsr } from 'iron-session/next'
import { NextApiHandler } from 'next'
import { User } from 'src/entity/User'

export const sessionOptions: IronSessionOptions = {
  password: process.env.SECRET_COOKIE_PASSWORD as string,
  cookieName: 'iron-session/examples/next.js',
  // secure: true should be used in production (HTTPS) but can't be used in development (HTTP)
  cookieOptions: {
    secure: process.env.NODE_ENV === 'production',
  },
}

// This is where we specify the typings of req.session.*
declare module 'iron-session' {
  interface IronSessionData {
    user?: User
  }
}

export function withSessionRoute(handle: NextApiHandler) {
  return withIronSessionApiRoute(handle, sessionOptions)
}

export function withSessionSsr(handler) {
  return withIronSessionSsr(handler, sessionOptions);
}
```

在 API Route 中使用

```ts
import { withSessionRoute } from "lib/withSession";

export default withSessionRoute(
  async function loginRoute(req, res) {
    // get user from database then:
    req.session.user = {
      id: 230,
      admin: true,
    };
    await req.session.save();
    res.send({ ok: true });
  }
);
```

在 getServerSideProps 中使用

```ts
import { withSessionSsr } from "lib/withSession";

export const getServerSideProps = withSessionSsr(
  async function getServerSideProps({ req }) {
    const user = req.session.user;

    if (user.admin !== true) {
      return {
        notFound: true,
      };
    }

    return {
      props: {
        user: req.session.user,
      },
    };
  }
);
```

## 添加全局环境变量

参考文档：[Loading Environment Variables](https://nextjs.org/docs/basic-features/environment-variables)

在根目录创建一个 `.env.local`，然后添加一个常量

```js
SECRET=xxx
```

在项目中使用

```js
process.env.SECRET
```

注意要在 `.gitignore` 中排除该文件

## 关于 Next Server

Next.js 的自动热更新只会重新运行当前目录下的文件，不会重新运行 `node_modules` 中的文件